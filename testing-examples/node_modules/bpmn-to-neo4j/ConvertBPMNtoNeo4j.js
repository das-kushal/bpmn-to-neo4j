import BpmnModdle from 'bpmn-moddle';
import mapBPMNtoNeo4j from './MapBPMNtoNeo4j.js';


export default async (bpmnXML, neo4jDriver) => {
  const moddle = new BpmnModdle();

  const data = await moddle.fromXML(bpmnXML);

  try {
    // Map BPMN elements to Neo4j nodes and relationships
    const neo4jData = mapBPMNtoNeo4j(data);


    const createNodeQueries = neo4jData.nodes.map((node) => {
      return `
            CREATE (n_${node.id}: ${node.type} {
              id: '${node.id}',
              name: '${node.name}'
            })
          `;
    });

    // Create relationships in Neo4j
    const createRelationshipQueries = neo4jData.relationships.map((relationship) => {
      return `
            MATCH (sourceNode:${relationship.source.type} { id: '${relationship.source.id}' }),
                  (targetNode:${relationship.target.type} { id: '${relationship.target.id}' })
            CREATE (sourceNode)-[:${relationship.type}]->(targetNode)
            RETURN sourceNode, targetNode
          `;
    });
    console.log('******INITIALISING SESSION**********')
    const session = neo4jDriver.session();

    // Run the Cypher queries in a transaction
    const txc = session.beginTransaction()
    try {
      const queries = [...createNodeQueries, ...createRelationshipQueries];
      queries.forEach(async (query) => await txc.run(query));
      console.log('Query completed')

      await txc.commit()
      console.log('committed')
    } catch (error) {
      console.log(error)
      await txc.rollback()
      console.log('rolled back')
    } finally {
      await session.close()
    }
    await session.close();
  } catch (error) {
    console.error('Error converting BPMN to Neo4j:', error);
  }
}